import { createRequire as _createRequire } from 'node:module';
const require = _createRequire(import.meta.url);
import {
  loadProjectGridAppContent
} from "./chunk-Z2CMHMLR.js";
import {
  deployAppResponseSchema,
  getDeploymentResponseSchema
} from "./chunk-H7756NJ6.js";
import {
  httpRequest
} from "./chunk-R5RJYQCX.js";
import {
  getDeployment
} from "./chunk-TXS6FIYJ.js";
import {
  DeploymentPipelinesStatus
} from "./chunk-7LCZ57SO.js";
import {
  AppType,
  DeploymentOperation,
  RcLabel,
  deployApp
} from "./chunk-Y7PQOTYY.js";
import {
  execa
} from "./chunk-RWTQFIPN.js";
import {
  pWaitFor
} from "./chunk-KONVQLDI.js";
import {
  CliError,
  CliErrorCode,
  require_lib
} from "./chunk-EW4XNYNT.js";
import {
  __toESM,
  init_esm_shims
} from "./chunk-4EFJZ3GQ.js";

// ../cli-site-old/src/git/index.ts
init_esm_shims();
var BASE_REMOTE_REF = "refs/remotes/";
var ORIGIN = "origin/";
var getDefaultBranch = async (writeCrashReport) => {
  try {
    const { stdout } = await execa("git", [
      "symbolic-ref",
      `${BASE_REMOTE_REF}${ORIGIN}HEAD`
    ]);
    const fullName = stdout.replace(BASE_REMOTE_REF, "");
    return fullName;
  } catch (error) {
    writeCrashReport(error);
    return null;
  }
};

// ../cli-site-old/src/gridapp/deployApp.ts
init_esm_shims();
var import_variant = __toESM(require_lib(), 1);
var DeploymentSource = (0, import_variant.variant)({
  local: {},
  remote: (0, import_variant.fields)()
});
async function getDeploymentSourceData(model, source) {
  return (0, import_variant.match)(source, {
    local: async () => ({
      deploymentData: {
        revision: model.revision,
        content: await loadProjectGridAppContent(model.projectFolder)
      }
    }),
    remote: () => ({})
  });
}
async function deployGridApp(opts) {
  const deploymentSourceData = await getDeploymentSourceData(
    opts.model,
    opts.source
  );
  try {
    const { data } = await httpRequest(
      {
        type: "code",
        authState: opts.authState
      },
      deployApp({
        deploymentOperation: opts.operation,
        appType: AppType.VELO_ISOLATED,
        ...deploymentSourceData,
        ...opts.operation === DeploymentOperation.RC && {
          rcDeploymentParams: {
            rcLabel: RcLabel.WIX_CLI
          }
        }
      }),
      { retries: 3, maxTimeout: 3 * 1e3 }
    );
    const result = deployAppResponseSchema.safeParse(data);
    if (!result.success) {
      throw new CliError({
        code: CliErrorCode.InvalidDeployAppResponse(),
        info: { data },
        cause: result.error
      });
    }
    return result.data.deploymentInfo;
  } catch (e) {
    throw new CliError({
      code: CliErrorCode.FailedToDeploySite(),
      cause: e
    });
  }
}
async function getDeploymentStatus({
  deploymentId,
  authState
}) {
  const deploymentStatus = await pWaitFor(
    async () => {
      try {
        const { data } = await httpRequest(
          {
            type: "editor",
            authState
          },
          getDeployment({
            deploymentId
          }),
          { retries: 2 }
        );
        const result = getDeploymentResponseSchema.safeParse(data);
        if (!result.success) {
          throw new CliError({
            code: CliErrorCode.InvalidGetDeploymentResponse(),
            info: { data },
            cause: result.error
          });
        }
        const status = result.data.deployment.deploymentPipelinesStatus;
        if (status === DeploymentPipelinesStatus.IN_PROGRESS) {
          return false;
        }
        return pWaitFor.resolveWith(status);
      } catch (err) {
        throw new CliError({
          code: CliErrorCode.FailedToGetDeploymentStatus(),
          cause: err
        });
      }
    },
    {
      // Poll each 2 seconds
      interval: 2 * 1e3,
      // Fail if 2 minutes passed
      timeout: 2 * 60 * 1e3
    }
  );
  return deploymentStatus;
}

export {
  getDefaultBranch,
  DeploymentSource,
  getDeploymentSourceData,
  deployGridApp,
  getDeploymentStatus
};
//# sourceMappingURL=chunk-CM2XSGSM.js.map